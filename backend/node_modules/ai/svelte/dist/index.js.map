{"version":3,"sources":["../index.ts","../../../../node_modules/.pnpm/swrev@4.0.0/node_modules/swrev/dist/swrev.mjs","../../../../node_modules/.pnpm/sswr@2.0.0_svelte@4.2.3/node_modules/sswr/dist/sswr.mjs","../use-chat.ts","../../shared/generate-id.ts","../../shared/stream-parts.ts","../../shared/read-data-stream.ts","../../shared/parse-complex-response.ts","../../shared/utils.ts","../../shared/call-chat-api.ts","../../shared/process-chat-stream.ts","../use-completion.ts","../../shared/call-completion-api.ts","../use-assistant.ts"],"sourcesContent":["export * from './use-chat';\nexport * from './use-completion';\nexport * from './use-assistant';\n","var P = Object.defineProperty;\nvar F = (r, e, t) => e in r ? P(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;\nvar h = (r, e, t) => (F(r, typeof e != \"symbol\" ? e + \"\" : e, t), t);\nclass I {\n  constructor() {\n    /**\n     * Stores the list of active listener.s\n     */\n    h(this, \"listeners\", /* @__PURE__ */ new Map());\n  }\n  /**\n   * Subscribes a given listener.\n   */\n  subscribe(e, t) {\n    this.listeners.has(e) || this.listeners.set(e, []), !this.listeners.get(e).includes(t) && this.listeners.get(e).push(t);\n  }\n  /**\n   * Unsubscribes the given listener.\n   */\n  unsubscribe(e, t) {\n    this.listeners.has(e) && this.listeners.get(e).includes(t) && (this.listeners.get(e).splice(this.listeners.get(e).indexOf(t), 1), this.listeners.get(e).length === 0 && this.listeners.delete(e));\n  }\n  /**\n   * Emits an event to all active listeners.\n   */\n  emit(e, t) {\n    this.listeners.has(e) && this.listeners.get(e).forEach((s) => s(t));\n  }\n}\nconst L = {\n  broadcast: !1\n}, S = {\n  broadcast: !1\n};\nclass O {\n  /**\n   * Creates the cache item given the data and expiration at.\n   */\n  constructor({ data: e, expiresAt: t = null }) {\n    /**\n     * Determines the data that's stored in the cache.\n     */\n    h(this, \"data\");\n    /**\n     * Determines the expiration date for the given set of data.\n     */\n    h(this, \"expiresAt\");\n    this.data = e, this.expiresAt = t;\n  }\n  /**\n   * Determines if the current cache item is still being resolved.\n   * This returns true if data is a promise, or false if type `D`.\n   */\n  isResolving() {\n    return this.data instanceof Promise;\n  }\n  /**\n   * Determines if the given cache item has expired.\n   */\n  hasExpired() {\n    return this.expiresAt === null || this.expiresAt < /* @__PURE__ */ new Date();\n  }\n  /**\n   * Set the expiration time of the given cache item relative to now.\n   */\n  expiresIn(e) {\n    return this.expiresAt = /* @__PURE__ */ new Date(), this.expiresAt.setMilliseconds(this.expiresAt.getMilliseconds() + e), this;\n  }\n}\nclass q {\n  constructor() {\n    /**\n     * Stores the elements of the cache in a key-value pair.\n     */\n    h(this, \"elements\", /* @__PURE__ */ new Map());\n    /**\n     * Stores the event target instance to dispatch and receive events.\n     */\n    h(this, \"event\", new I());\n  }\n  /**\n   * Resolves the promise and replaces the Promise to the resolved data.\n   * It also broadcasts the value change if needed or deletes the key if\n   * the value resolves to undefined or null.\n   */\n  resolve(e, t) {\n    Promise.resolve(t.data).then((s) => {\n      if (s == null)\n        return this.remove(e);\n      t.data = s, this.broadcast(e, s);\n    });\n  }\n  /**\n   * Gets an element from the cache.\n   *\n   * It is assumed the item always exist when\n   * you get it. Use the has method to check\n   * for the existence of it.\n   */\n  get(e) {\n    return this.elements.get(e);\n  }\n  /**\n   * Sets an element to the cache.\n   */\n  set(e, t) {\n    this.elements.set(e, t), this.resolve(e, t);\n  }\n  /**\n   * Removes an key-value pair from the cache.\n   */\n  remove(e, t) {\n    const { broadcast: s } = { ...L, ...t };\n    s && this.broadcast(e, void 0), this.elements.delete(e);\n  }\n  /**\n   * Removes all the key-value pairs from the cache.\n   */\n  clear(e) {\n    const { broadcast: t } = { ...S, ...e };\n    if (t)\n      for (const s of this.elements.keys())\n        this.broadcast(s, void 0);\n    this.elements.clear();\n  }\n  /**\n   * Determines if the given key exists\n   * in the cache.\n   */\n  has(e) {\n    return this.elements.has(e);\n  }\n  /**\n   * Subscribes the callback to the given key.\n   */\n  subscribe(e, t) {\n    this.event.subscribe(e, t);\n  }\n  /**\n   * Unsubscribes to the given key events.\n   */\n  unsubscribe(e, t) {\n    this.event.unsubscribe(e, t);\n  }\n  /**\n   * Broadcasts a value change  on all subscribed instances.\n   */\n  broadcast(e, t) {\n    this.event.emit(e, t);\n  }\n}\nconst x = {\n  cache: new q(),\n  errors: new I(),\n  fetcher: async (r) => {\n    const e = await fetch(r);\n    if (!e.ok)\n      throw Error(\"Not a 2XX response.\");\n    return e.json();\n  },\n  fallbackData: void 0,\n  loadInitialCache: !0,\n  revalidateOnStart: !0,\n  dedupingInterval: 2e3,\n  revalidateOnFocus: !0,\n  focusThrottleInterval: 5e3,\n  revalidateOnReconnect: !0,\n  reconnectWhen: (r, { enabled: e }) => e && typeof window < \"u\" ? (window.addEventListener(\"online\", r), () => window.removeEventListener(\"online\", r)) : () => {\n  },\n  focusWhen: (r, { enabled: e, throttleInterval: t }) => {\n    if (e && typeof window < \"u\") {\n      let s = null;\n      const i = () => {\n        const a = Date.now();\n        (s === null || a - s > t) && (s = a, r());\n      };\n      return window.addEventListener(\"focus\", i), () => window.removeEventListener(\"focus\", i);\n    }\n    return () => {\n    };\n  },\n  revalidateFunction: void 0\n}, E = {\n  ...x,\n  force: !1\n}, T = {\n  revalidate: !0,\n  revalidateOptions: { ...E },\n  revalidateFunction: void 0\n}, X = {\n  broadcast: !1\n};\nclass H {\n  /**\n   * Creates a new instance of SWR.\n   */\n  constructor(e) {\n    /**\n     * Stores the options of the SWR.\n     */\n    h(this, \"options\");\n    this.options = { ...x, ...e };\n  }\n  /**\n   * Gets the cache of the SWR.\n   */\n  get cache() {\n    return this.options.cache;\n  }\n  /**\n   * Gets the cache of the SWR.\n   */\n  get errors() {\n    return this.options.errors;\n  }\n  /**\n   * Requests the data using the provided fetcher.\n   */\n  async requestData(e, t) {\n    return await Promise.resolve(t(e)).catch((s) => {\n      throw this.errors.emit(e, s), s;\n    });\n  }\n  /**\n   * Resolves the given to a SWRKey or undefined.\n   */\n  resolveKey(e) {\n    if (typeof e == \"function\")\n      try {\n        return e();\n      } catch {\n        return;\n      }\n    return e;\n  }\n  /**\n   * Clear the specified keys from the cache. If no keys\n   * are specified, it clears all the cache keys.\n   */\n  clear(e, t) {\n    const s = { ...X, ...t };\n    if (e == null)\n      return this.cache.clear(s);\n    if (!Array.isArray(e))\n      return this.cache.remove(e, s);\n    for (const i of e)\n      this.cache.remove(i, s);\n  }\n  /**\n   * Revalidates the key and mutates the cache if needed.\n   */\n  async revalidate(e, t) {\n    if (!e)\n      throw new Error(\"[Revalidate] Key issue: ${key}\");\n    const { fetcher: s, dedupingInterval: i } = this.options, { force: a, fetcher: o, dedupingInterval: n } = {\n      ...E,\n      fetcher: s,\n      dedupingInterval: i,\n      ...t\n    };\n    if (a || !this.cache.has(e) || this.cache.has(e) && this.cache.get(e).hasExpired()) {\n      const c = this.requestData(e, o), l = c.catch(() => {\n      });\n      return this.cache.set(e, new O({ data: l }).expiresIn(n)), await c;\n    }\n    return this.getWait(e);\n  }\n  /**\n   * Mutates the data of a given key with a new value.\n   * This is used to replace the cache contents of the\n   * given key manually.\n   */\n  async mutate(e, t, s) {\n    if (!e)\n      throw new Error(\"[Mutate] Key issue: ${key}\");\n    const {\n      revalidate: i,\n      revalidateOptions: a,\n      revalidateFunction: o\n    } = {\n      ...T,\n      ...s\n    };\n    let n;\n    if (typeof t == \"function\") {\n      let c;\n      if (this.cache.has(e)) {\n        const l = this.cache.get(e);\n        l.isResolving() || (c = l.data);\n      }\n      n = t(c);\n    } else\n      n = t;\n    return this.cache.set(e, new O({ data: n })), i ? await ((o == null ? void 0 : o(e, a)) ?? this.revalidate(e, a)) : n;\n  }\n  /**\n   * Gets the data of the given key. Keep in mind\n   * this data will be stale and revalidate in the background\n   * unless specified otherwise.\n   */\n  subscribeData(e, t) {\n    if (e) {\n      const s = (i) => t(i);\n      return this.cache.subscribe(e, s), () => this.cache.unsubscribe(e, s);\n    }\n    return () => {\n    };\n  }\n  /**\n   * Subscribes to errors on the given key.\n   */\n  subscribeErrors(e, t) {\n    if (e) {\n      const s = (i) => t(i);\n      return this.errors.subscribe(e, s), () => this.errors.unsubscribe(e, s);\n    }\n    return () => {\n    };\n  }\n  /**\n   * Gets the current cached data of the given key.\n   * This does not trigger any revalidation nor mutation\n   * of the data.\n   * - If the data has never been validated\n   * (there is no cache) it will return undefined.\n   * - If the item is pending to resolve (there is a request\n   * pending to resolve) it will return undefined.\n   */\n  get(e) {\n    if (e && this.cache.has(e)) {\n      const t = this.cache.get(e);\n      if (!t.isResolving())\n        return t.data;\n    }\n  }\n  /**\n   * Gets an element from the cache. The difference\n   * with the get is that this method returns a promise\n   * that will resolve the the value. If there's no item\n   * in the cache, it will wait for it before resolving.\n   */\n  getWait(e) {\n    return new Promise((t, s) => {\n      const i = this.subscribeData(e, (n) => {\n        if (i(), n !== void 0)\n          return t(n);\n      }), a = this.subscribeErrors(e, (n) => {\n        if (a(), n !== void 0)\n          return s(n);\n      }), o = this.get(e);\n      if (o !== void 0)\n        return t(o);\n    });\n  }\n  /**\n   * Use a SWR value given the key and\n   * subscribe to future changes.\n   */\n  subscribe(e, t, s, i) {\n    const {\n      fetcher: a,\n      fallbackData: o,\n      loadInitialCache: n,\n      revalidateOnStart: c,\n      dedupingInterval: l,\n      revalidateOnFocus: A,\n      focusThrottleInterval: C,\n      revalidateOnReconnect: R,\n      reconnectWhen: W,\n      focusWhen: D,\n      revalidateFunction: d\n    } = {\n      // Current instance options\n      // (includes default options)\n      ...this.options,\n      // Current call options.\n      ...i\n    }, K = (m) => (d == null ? void 0 : d(this.resolveKey(e), m)) ?? this.revalidate(this.resolveKey(e), m), f = () => K({ fetcher: a, dedupingInterval: l }), u = n ? this.get(this.resolveKey(e)) : o ?? void 0, g = c ? f() : Promise.resolve(void 0), M = u ? Promise.resolve(u) : g;\n    u && (t == null || t(u));\n    const v = t ? this.subscribeData(this.resolveKey(e), t) : void 0, b = s ? this.subscribeErrors(this.resolveKey(e), s) : void 0, p = D(f, {\n      throttleInterval: C,\n      enabled: A\n    }), w = W(f, {\n      enabled: R\n    });\n    return { unsubscribe: () => {\n      v == null || v(), b == null || b(), p == null || p(), w == null || w();\n    }, dataPromise: M, revalidatePromise: g };\n  }\n}\nexport {\n  O as CacheItem,\n  q as DefaultCache,\n  I as DefaultSWREventManager,\n  H as SWR,\n  S as defaultCacheClearOptions,\n  L as defaultCacheRemoveOptions,\n  X as defaultClearOptions,\n  T as defaultMutateOptions,\n  x as defaultOptions,\n  E as defaultRevalidateOptions\n};\n","import { SWR as _ } from \"swrev\";\nimport { beforeUpdate as w, onDestroy as E } from \"svelte\";\nfunction p() {\n}\nfunction D(t) {\n  return t();\n}\nfunction q(t) {\n  t.forEach(D);\n}\nfunction x(t) {\n  return typeof t == \"function\";\n}\nfunction K(t, e) {\n  return t != t ? e == e : t !== e || t && typeof t == \"object\" || typeof t == \"function\";\n}\nfunction z(t, ...e) {\n  if (t == null) {\n    for (const r of e)\n      r(void 0);\n    return p;\n  }\n  const n = t.subscribe(...e);\n  return n.unsubscribe ? () => n.unsubscribe() : n;\n}\nconst v = [];\nfunction A(t, e) {\n  return {\n    subscribe: y(t, e).subscribe\n  };\n}\nfunction y(t, e = p) {\n  let n;\n  const r = /* @__PURE__ */ new Set();\n  function i(u) {\n    if (K(t, u) && (t = u, n)) {\n      const f = !v.length;\n      for (const s of r)\n        s[1](), v.push(s, t);\n      if (f) {\n        for (let s = 0; s < v.length; s += 2)\n          v[s][0](v[s + 1]);\n        v.length = 0;\n      }\n    }\n  }\n  function a(u) {\n    i(u(t));\n  }\n  function d(u, f = p) {\n    const s = [u, f];\n    return r.add(s), r.size === 1 && (n = e(i, a) || p), u(t), () => {\n      r.delete(s), r.size === 0 && n && (n(), n = null);\n    };\n  }\n  return { set: i, update: a, subscribe: d };\n}\nfunction S(t, e, n) {\n  const r = !Array.isArray(t), i = r ? [t] : t;\n  if (!i.every(Boolean))\n    throw new Error(\"derived() expects stores as input, got a falsy value\");\n  const a = e.length < 2;\n  return A(n, (d, u) => {\n    let f = !1;\n    const s = [];\n    let h = 0, o = p;\n    const l = () => {\n      if (h)\n        return;\n      o();\n      const b = e(r ? s[0] : s, d, u);\n      a ? d(b) : o = x(b) ? b : p;\n    }, g = i.map(\n      (b, m) => z(\n        b,\n        (R) => {\n          s[m] = R, h &= ~(1 << m), f && l();\n        },\n        () => {\n          h |= 1 << m;\n        }\n      )\n    );\n    return f = !0, l(), function() {\n      q(g), o(), f = !1;\n    };\n  });\n}\nclass O extends _ {\n  /**\n   * Svelte specific use of SWR.\n   */\n  useSWR(e, n) {\n    let r;\n    const i = y(void 0, () => () => r == null ? void 0 : r()), a = y(void 0, () => () => r == null ? void 0 : r());\n    w(() => {\n      const o = (g) => {\n        a.set(void 0), i.set(g);\n      }, l = (g) => a.set(g);\n      r || (r = this.subscribe(e, o, l, {\n        loadInitialCache: !0,\n        ...n\n      }).unsubscribe);\n    }), E(() => r == null ? void 0 : r());\n    const d = (o, l) => this.mutate(this.resolveKey(e), o, {\n      revalidateOptions: n,\n      ...l\n    }), u = (o) => this.revalidate(this.resolveKey(e), { ...n, ...o }), f = (o) => this.clear(this.resolveKey(e), o), s = S([i, a], ([o, l]) => o === void 0 && l === void 0), h = S([i, a], ([o, l]) => o !== void 0 && l === void 0);\n    return { data: i, error: a, mutate: d, revalidate: u, clear: f, isLoading: s, isValid: h };\n  }\n}\nconst W = (t) => new O(t);\nlet c = W();\nconst C = (t) => (c = W(t), c), I = (t, e) => c.subscribeData(t, e), L = (t, e) => c.subscribeErrors(t, e), U = (t) => c.get(t), V = (t) => c.getWait(t), $ = (t, e, n, r) => c.subscribe(t, e, n, r), F = (t, e) => c.useSWR(t, e), G = (t, e, n) => c.mutate(t, e, n), H = (t, e) => c.revalidate(t, e), J = (t, e) => c.clear(t, e);\nexport {\n  O as SSWR,\n  J as clear,\n  C as createDefaultSWR,\n  W as createSWR,\n  U as get,\n  V as getOrWait,\n  G as mutate,\n  H as revalidate,\n  I as subscribe,\n  L as subscribeErrors,\n  c as swr,\n  $ as use,\n  F as useSWR\n};\n","import { useSWR } from 'sswr';\nimport { Readable, Writable, derived, get, writable } from 'svelte/store';\nimport { callChatApi } from '../shared/call-chat-api';\nimport { processChatStream } from '../shared/process-chat-stream';\nimport type {\n  ChatRequest,\n  ChatRequestOptions,\n  CreateMessage,\n  IdGenerator,\n  JSONValue,\n  Message,\n  UseChatOptions,\n} from '../shared/types';\nimport { generateId as generateIdFunc } from '../shared/generate-id';\nexport type { CreateMessage, Message, UseChatOptions };\n\nexport type UseChatHelpers = {\n  /** Current messages in the chat */\n  messages: Readable<Message[]>;\n  /** The error object of the API request */\n  error: Readable<undefined | Error>;\n  /**\n   * Append a user message to the chat list. This triggers the API call to fetch\n   * the assistant's response.\n   * @param message The message to append\n   * @param chatRequestOptions Additional options to pass to the API call\n   */\n  append: (\n    message: Message | CreateMessage,\n    chatRequestOptions?: ChatRequestOptions,\n  ) => Promise<string | null | undefined>;\n  /**\n   * Reload the last AI chat response for the given chat history. If the last\n   * message isn't from the assistant, it will request the API to generate a\n   * new response.\n   */\n  reload: (\n    chatRequestOptions?: ChatRequestOptions,\n  ) => Promise<string | null | undefined>;\n  /**\n   * Abort the current request immediately, keep the generated tokens if any.\n   */\n  stop: () => void;\n  /**\n   * Update the `messages` state locally. This is useful when you want to\n   * edit the messages on the client, and then trigger the `reload` method\n   * manually to regenerate the AI response.\n   */\n  setMessages: (messages: Message[]) => void;\n  /** The current value of the input */\n  input: Writable<string>;\n  /** Form submission handler to automatically reset input and append a user message  */\n  handleSubmit: (e: any, chatRequestOptions?: ChatRequestOptions) => void;\n  metadata?: Object;\n  /** Whether the API request is in progress */\n  isLoading: Readable<boolean | undefined>;\n\n  /** Additional data added on the server via StreamData */\n  data: Readable<JSONValue[] | undefined>;\n};\nconst getStreamedResponse = async (\n  api: string,\n  chatRequest: ChatRequest,\n  mutate: (messages: Message[]) => void,\n  mutateStreamData: (data: JSONValue[] | undefined) => void,\n  existingData: JSONValue[] | undefined,\n  extraMetadata: {\n    credentials?: RequestCredentials;\n    headers?: Record<string, string> | Headers;\n    body?: any;\n  },\n  previousMessages: Message[],\n  abortControllerRef: AbortController | null,\n  generateId: IdGenerator,\n  streamMode?: 'stream-data' | 'text',\n  onFinish?: (message: Message) => void,\n  onResponse?: (response: Response) => void | Promise<void>,\n  sendExtraMessageFields?: boolean,\n) => {\n  // Do an optimistic update to the chat state to show the updated messages\n  // immediately.\n  mutate(chatRequest.messages);\n\n  const constructedMessagesPayload = sendExtraMessageFields\n    ? chatRequest.messages\n    : chatRequest.messages.map(\n        ({ role, content, name, function_call, tool_calls, tool_call_id }) => ({\n          role,\n          content,\n          tool_call_id,\n          ...(name !== undefined && { name }),\n          ...(function_call !== undefined && {\n            function_call: function_call,\n          }),\n          ...(tool_calls !== undefined && {\n            tool_calls: tool_calls,\n          }),\n        }),\n      );\n\n  return await callChatApi({\n    api,\n    messages: constructedMessagesPayload,\n    body: {\n      ...extraMetadata.body,\n      ...chatRequest.options?.body,\n      ...(chatRequest.functions !== undefined && {\n        functions: chatRequest.functions,\n      }),\n      ...(chatRequest.function_call !== undefined && {\n        function_call: chatRequest.function_call,\n      }),\n      ...(chatRequest.tools !== undefined && {\n        tools: chatRequest.tools,\n      }),\n      ...(chatRequest.tool_choice !== undefined && {\n        tool_choice: chatRequest.tool_choice,\n      }),\n    },\n    streamMode,\n    credentials: extraMetadata.credentials,\n    headers: {\n      ...extraMetadata.headers,\n      ...chatRequest.options?.headers,\n    },\n    abortController: () => abortControllerRef,\n    restoreMessagesOnFailure() {\n      mutate(previousMessages);\n    },\n    onResponse,\n    onUpdate(merged, data) {\n      mutate([...chatRequest.messages, ...merged]);\n      mutateStreamData([...(existingData || []), ...(data || [])]);\n    },\n    onFinish,\n    generateId,\n  });\n};\n\nlet uniqueId = 0;\n\nconst store: Record<string, Message[] | undefined> = {};\n\nexport function useChat({\n  api = '/api/chat',\n  id,\n  initialMessages = [],\n  initialInput = '',\n  sendExtraMessageFields,\n  experimental_onFunctionCall,\n  experimental_onToolCall,\n  streamMode,\n  onResponse,\n  onFinish,\n  onError,\n  credentials,\n  headers,\n  body,\n  generateId = generateIdFunc,\n}: UseChatOptions = {}): UseChatHelpers {\n  // Generate a unique id for the chat if not provided.\n  const chatId = id || `chat-${uniqueId++}`;\n\n  const key = `${api}|${chatId}`;\n  const {\n    data,\n    mutate: originalMutate,\n    isLoading: isSWRLoading,\n  } = useSWR<Message[]>(key, {\n    fetcher: () => store[key] || initialMessages,\n    fallbackData: initialMessages,\n  });\n\n  const streamData = writable<JSONValue[] | undefined>(undefined);\n\n  const loading = writable<boolean>(false);\n\n  // Force the `data` to be `initialMessages` if it's `undefined`.\n  data.set(initialMessages);\n\n  const mutate = (data: Message[]) => {\n    store[key] = data;\n    return originalMutate(data);\n  };\n\n  // Because of the `fallbackData` option, the `data` will never be `undefined`.\n  const messages = data as Writable<Message[]>;\n\n  // Abort controller to cancel the current API call.\n  let abortController: AbortController | null = null;\n\n  const extraMetadata = {\n    credentials,\n    headers,\n    body,\n  };\n\n  const error = writable<undefined | Error>(undefined);\n\n  // Actual mutation hook to send messages to the API endpoint and update the\n  // chat state.\n  async function triggerRequest(chatRequest: ChatRequest) {\n    try {\n      error.set(undefined);\n      loading.set(true);\n      abortController = new AbortController();\n\n      await processChatStream({\n        getStreamedResponse: () =>\n          getStreamedResponse(\n            api,\n            chatRequest,\n            mutate,\n            data => {\n              streamData.set(data);\n            },\n            get(streamData),\n            extraMetadata,\n            get(messages),\n            abortController,\n            generateId,\n            streamMode,\n            onFinish,\n            onResponse,\n            sendExtraMessageFields,\n          ),\n        experimental_onFunctionCall,\n        experimental_onToolCall,\n        updateChatRequest: chatRequestParam => {\n          chatRequest = chatRequestParam;\n        },\n        getCurrentMessages: () => get(messages),\n      });\n\n      abortController = null;\n\n      return null;\n    } catch (err) {\n      // Ignore abort errors as they are expected.\n      if ((err as any).name === 'AbortError') {\n        abortController = null;\n        return null;\n      }\n\n      if (onError && err instanceof Error) {\n        onError(err);\n      }\n\n      error.set(err as Error);\n    } finally {\n      loading.set(false);\n    }\n  }\n\n  const append: UseChatHelpers['append'] = async (\n    message: Message | CreateMessage,\n    {\n      options,\n      functions,\n      function_call,\n      tools,\n      tool_choice,\n    }: ChatRequestOptions = {},\n  ) => {\n    if (!message.id) {\n      message.id = generateId();\n    }\n\n    const chatRequest: ChatRequest = {\n      messages: get(messages).concat(message as Message),\n      options,\n      ...(functions !== undefined && { functions }),\n      ...(function_call !== undefined && { function_call }),\n      ...(tools !== undefined && { tools }),\n      ...(tool_choice !== undefined && { tool_choice }),\n    };\n    return triggerRequest(chatRequest);\n  };\n\n  const reload: UseChatHelpers['reload'] = async ({\n    options,\n    functions,\n    function_call,\n    tools,\n    tool_choice,\n  }: ChatRequestOptions = {}) => {\n    const messagesSnapshot = get(messages);\n    if (messagesSnapshot.length === 0) return null;\n\n    // Remove last assistant message and retry last user message.\n    const lastMessage = messagesSnapshot.at(-1);\n    if (lastMessage?.role === 'assistant') {\n      const chatRequest: ChatRequest = {\n        messages: messagesSnapshot.slice(0, -1),\n        options,\n        ...(functions !== undefined && { functions }),\n        ...(function_call !== undefined && { function_call }),\n        ...(tools !== undefined && { tools }),\n        ...(tool_choice !== undefined && { tool_choice }),\n      };\n\n      return triggerRequest(chatRequest);\n    }\n    const chatRequest: ChatRequest = {\n      messages: messagesSnapshot,\n      options,\n      ...(functions !== undefined && { functions }),\n      ...(function_call !== undefined && { function_call }),\n      ...(tools !== undefined && { tools }),\n      ...(tool_choice !== undefined && { tool_choice }),\n    };\n\n    return triggerRequest(chatRequest);\n  };\n\n  const stop = () => {\n    if (abortController) {\n      abortController.abort();\n      abortController = null;\n    }\n  };\n\n  const setMessages = (messages: Message[]) => {\n    mutate(messages);\n  };\n\n  const input = writable(initialInput);\n\n  const handleSubmit = (e: any, options: ChatRequestOptions = {}) => {\n    e.preventDefault();\n    const inputValue = get(input);\n    if (!inputValue) return;\n\n    append(\n      {\n        content: inputValue,\n        role: 'user',\n        createdAt: new Date(),\n      },\n      options,\n    );\n    input.set('');\n  };\n\n  const isLoading = derived(\n    [isSWRLoading, loading],\n    ([$isSWRLoading, $loading]) => {\n      return $isSWRLoading || $loading;\n    },\n  );\n\n  return {\n    messages,\n    error,\n    append,\n    reload,\n    stop,\n    setMessages,\n    input,\n    handleSubmit,\n    isLoading,\n    data: streamData,\n  };\n}\n","import { customAlphabet } from 'nanoid/non-secure';\n\n/**\n * Generates a 7-character random string to use for IDs. Not secure.\n */\nexport const generateId = customAlphabet(\n  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  7,\n);\n","import { ToolCall as CoreToolCall } from '../core/generate-text/tool-call';\nimport { ToolResult as CoreToolResult } from '../core/generate-text/tool-result';\nimport {\n  AssistantMessage,\n  DataMessage,\n  FunctionCall,\n  JSONValue,\n  ToolCall,\n} from './types';\nimport { StreamString } from './utils';\n\nexport interface StreamPart<CODE extends string, NAME extends string, TYPE> {\n  code: CODE;\n  name: NAME;\n  parse: (value: JSONValue) => { type: NAME; value: TYPE };\n}\n\nconst textStreamPart: StreamPart<'0', 'text', string> = {\n  code: '0',\n  name: 'text',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: 'text', value };\n  },\n};\n\nconst functionCallStreamPart: StreamPart<\n  '1',\n  'function_call',\n  { function_call: FunctionCall }\n> = {\n  code: '1',\n  name: 'function_call',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('function_call' in value) ||\n      typeof value.function_call !== 'object' ||\n      value.function_call == null ||\n      !('name' in value.function_call) ||\n      !('arguments' in value.function_call) ||\n      typeof value.function_call.name !== 'string' ||\n      typeof value.function_call.arguments !== 'string'\n    ) {\n      throw new Error(\n        '\"function_call\" parts expect an object with a \"function_call\" property.',\n      );\n    }\n\n    return {\n      type: 'function_call',\n      value: value as unknown as { function_call: FunctionCall },\n    };\n  },\n};\n\nconst dataStreamPart: StreamPart<'2', 'data', Array<JSONValue>> = {\n  code: '2',\n  name: 'data',\n  parse: (value: JSONValue) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"data\" parts expect an array value.');\n    }\n\n    return { type: 'data', value };\n  },\n};\n\nconst errorStreamPart: StreamPart<'3', 'error', string> = {\n  code: '3',\n  name: 'error',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: 'error', value };\n  },\n};\n\nconst assistantMessageStreamPart: StreamPart<\n  '4',\n  'assistant_message',\n  AssistantMessage\n> = {\n  code: '4',\n  name: 'assistant_message',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('id' in value) ||\n      !('role' in value) ||\n      !('content' in value) ||\n      typeof value.id !== 'string' ||\n      typeof value.role !== 'string' ||\n      value.role !== 'assistant' ||\n      !Array.isArray(value.content) ||\n      !value.content.every(\n        item =>\n          item != null &&\n          typeof item === 'object' &&\n          'type' in item &&\n          item.type === 'text' &&\n          'text' in item &&\n          item.text != null &&\n          typeof item.text === 'object' &&\n          'value' in item.text &&\n          typeof item.text.value === 'string',\n      )\n    ) {\n      throw new Error(\n        '\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.',\n      );\n    }\n\n    return {\n      type: 'assistant_message',\n      value: value as AssistantMessage,\n    };\n  },\n};\n\nconst assistantControlDataStreamPart: StreamPart<\n  '5',\n  'assistant_control_data',\n  {\n    threadId: string;\n    messageId: string;\n  }\n> = {\n  code: '5',\n  name: 'assistant_control_data',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('threadId' in value) ||\n      !('messageId' in value) ||\n      typeof value.threadId !== 'string' ||\n      typeof value.messageId !== 'string'\n    ) {\n      throw new Error(\n        '\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.',\n      );\n    }\n\n    return {\n      type: 'assistant_control_data',\n      value: {\n        threadId: value.threadId,\n        messageId: value.messageId,\n      },\n    };\n  },\n};\n\nconst dataMessageStreamPart: StreamPart<'6', 'data_message', DataMessage> = {\n  code: '6',\n  name: 'data_message',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('role' in value) ||\n      !('data' in value) ||\n      typeof value.role !== 'string' ||\n      value.role !== 'data'\n    ) {\n      throw new Error(\n        '\"data_message\" parts expect an object with a \"role\" and \"data\" property.',\n      );\n    }\n\n    return {\n      type: 'data_message',\n      value: value as DataMessage,\n    };\n  },\n};\n\nconst toolCallsStreamPart: StreamPart<\n  '7',\n  'tool_calls',\n  { tool_calls: ToolCall[] }\n> = {\n  code: '7',\n  name: 'tool_calls',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('tool_calls' in value) ||\n      typeof value.tool_calls !== 'object' ||\n      value.tool_calls == null ||\n      !Array.isArray(value.tool_calls) ||\n      value.tool_calls.some(\n        tc =>\n          tc == null ||\n          typeof tc !== 'object' ||\n          !('id' in tc) ||\n          typeof tc.id !== 'string' ||\n          !('type' in tc) ||\n          typeof tc.type !== 'string' ||\n          !('function' in tc) ||\n          tc.function == null ||\n          typeof tc.function !== 'object' ||\n          !('arguments' in tc.function) ||\n          typeof tc.function.name !== 'string' ||\n          typeof tc.function.arguments !== 'string',\n      )\n    ) {\n      throw new Error(\n        '\"tool_calls\" parts expect an object with a ToolCallPayload.',\n      );\n    }\n\n    return {\n      type: 'tool_calls',\n      value: value as unknown as { tool_calls: ToolCall[] },\n    };\n  },\n};\n\nconst messageAnnotationsStreamPart: StreamPart<\n  '8',\n  'message_annotations',\n  Array<JSONValue>\n> = {\n  code: '8',\n  name: 'message_annotations',\n  parse: (value: JSONValue) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"message_annotations\" parts expect an array value.');\n    }\n\n    return { type: 'message_annotations', value };\n  },\n};\n\nconst toolCallStreamPart: StreamPart<\n  '9',\n  'tool_call',\n  CoreToolCall<string, any>\n> = {\n  code: '9',\n  name: 'tool_call',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('toolName' in value) ||\n      typeof value.toolName !== 'string' ||\n      !('args' in value) ||\n      typeof value.args !== 'object'\n    ) {\n      throw new Error(\n        '\"tool_call\" parts expect an object with a \"toolCallId\", \"toolName\", and \"args\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call',\n      value: value as unknown as CoreToolCall<string, any>,\n    };\n  },\n};\n\nconst toolResultStreamPart: StreamPart<\n  'a',\n  'tool_result',\n  CoreToolResult<string, any, any>\n> = {\n  code: 'a',\n  name: 'tool_result',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('toolName' in value) ||\n      typeof value.toolName !== 'string' ||\n      !('args' in value) ||\n      typeof value.args !== 'object' ||\n      !('result' in value)\n    ) {\n      throw new Error(\n        '\"tool_result\" parts expect an object with a \"toolCallId\", \"toolName\", \"args\", and \"result\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_result',\n      value: value as unknown as CoreToolResult<string, any, any>,\n    };\n  },\n};\n\nconst streamParts = [\n  textStreamPart,\n  functionCallStreamPart,\n  dataStreamPart,\n  errorStreamPart,\n  assistantMessageStreamPart,\n  assistantControlDataStreamPart,\n  dataMessageStreamPart,\n  toolCallsStreamPart,\n  messageAnnotationsStreamPart,\n  toolCallStreamPart,\n  toolResultStreamPart,\n] as const;\n\n// union type of all stream parts\ntype StreamParts =\n  | typeof textStreamPart\n  | typeof functionCallStreamPart\n  | typeof dataStreamPart\n  | typeof errorStreamPart\n  | typeof assistantMessageStreamPart\n  | typeof assistantControlDataStreamPart\n  | typeof dataMessageStreamPart\n  | typeof toolCallsStreamPart\n  | typeof messageAnnotationsStreamPart\n  | typeof toolCallStreamPart\n  | typeof toolResultStreamPart;\n\n/**\n * Maps the type of a stream part to its value type.\n */\ntype StreamPartValueType = {\n  [P in StreamParts as P['name']]: ReturnType<P['parse']>['value'];\n};\n\nexport type StreamPartType =\n  | ReturnType<typeof textStreamPart.parse>\n  | ReturnType<typeof functionCallStreamPart.parse>\n  | ReturnType<typeof dataStreamPart.parse>\n  | ReturnType<typeof errorStreamPart.parse>\n  | ReturnType<typeof assistantMessageStreamPart.parse>\n  | ReturnType<typeof assistantControlDataStreamPart.parse>\n  | ReturnType<typeof dataMessageStreamPart.parse>\n  | ReturnType<typeof toolCallsStreamPart.parse>\n  | ReturnType<typeof messageAnnotationsStreamPart.parse>\n  | ReturnType<typeof toolCallStreamPart.parse>\n  | ReturnType<typeof toolResultStreamPart.parse>;\n\nexport const streamPartsByCode = {\n  [textStreamPart.code]: textStreamPart,\n  [functionCallStreamPart.code]: functionCallStreamPart,\n  [dataStreamPart.code]: dataStreamPart,\n  [errorStreamPart.code]: errorStreamPart,\n  [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n  [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n  [dataMessageStreamPart.code]: dataMessageStreamPart,\n  [toolCallsStreamPart.code]: toolCallsStreamPart,\n  [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart,\n  [toolCallStreamPart.code]: toolCallStreamPart,\n  [toolResultStreamPart.code]: toolResultStreamPart,\n} as const;\n\n/**\n * The map of prefixes for data in the stream\n *\n * - 0: Text from the LLM response\n * - 1: (OpenAI) function_call responses\n * - 2: custom JSON added by the user using `Data`\n * - 6: (OpenAI) tool_call responses\n *\n * Example:\n * ```\n * 0:Vercel\n * 0:'s\n * 0: AI\n * 0: AI\n * 0: SDK\n * 0: is great\n * 0:!\n * 2: { \"someJson\": \"value\" }\n * 1: {\"function_call\": {\"name\": \"get_current_weather\", \"arguments\": \"{\\\\n\\\\\"location\\\\\": \\\\\"Charlottesville, Virginia\\\\\",\\\\n\\\\\"format\\\\\": \\\\\"celsius\\\\\"\\\\n}\"}}\n * 6: {\"tool_call\": {\"id\": \"tool_0\", \"type\": \"function\", \"function\": {\"name\": \"get_current_weather\", \"arguments\": \"{\\\\n\\\\\"location\\\\\": \\\\\"Charlottesville, Virginia\\\\\",\\\\n\\\\\"format\\\\\": \\\\\"celsius\\\\\"\\\\n}\"}}}\n *```\n */\nexport const StreamStringPrefixes = {\n  [textStreamPart.name]: textStreamPart.code,\n  [functionCallStreamPart.name]: functionCallStreamPart.code,\n  [dataStreamPart.name]: dataStreamPart.code,\n  [errorStreamPart.name]: errorStreamPart.code,\n  [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n  [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n  [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n  [toolCallsStreamPart.name]: toolCallsStreamPart.code,\n  [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code,\n  [toolCallStreamPart.name]: toolCallStreamPart.code,\n  [toolResultStreamPart.name]: toolResultStreamPart.code,\n} as const;\n\nexport const validCodes = streamParts.map(part => part.code);\n\n/**\nParses a stream part from a string.\n\n@param line The string to parse.\n@returns The parsed stream part.\n@throws An error if the string cannot be parsed.\n */\nexport const parseStreamPart = (line: string): StreamPartType => {\n  const firstSeparatorIndex = line.indexOf(':');\n\n  if (firstSeparatorIndex === -1) {\n    throw new Error('Failed to parse stream string. No separator found.');\n  }\n\n  const prefix = line.slice(0, firstSeparatorIndex);\n\n  if (!validCodes.includes(prefix as keyof typeof streamPartsByCode)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n\n  const code = prefix as keyof typeof streamPartsByCode;\n\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue: JSONValue = JSON.parse(textValue);\n\n  return streamPartsByCode[code].parse(jsonValue);\n};\n\n/**\nPrepends a string with a prefix from the `StreamChunkPrefixes`, JSON-ifies it,\nand appends a new line.\n\nIt ensures type-safety for the part type and value.\n */\nexport function formatStreamPart<T extends keyof StreamPartValueType>(\n  type: T,\n  value: StreamPartValueType[T],\n): StreamString {\n  const streamPart = streamParts.find(part => part.name === type);\n\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n\n  return `${streamPart.code}:${JSON.stringify(value)}\\n`;\n}\n","import { StreamPartType, parseStreamPart } from './stream-parts';\n\nconst NEWLINE = '\\n'.charCodeAt(0);\n\n// concatenates all the chunks into a single Uint8Array\nfunction concatChunks(chunks: Uint8Array[], totalLength: number) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n\n  return concatenatedChunks;\n}\n\n/**\nConverts a ReadableStreamDefaultReader into an async generator that yields\nStreamPart objects.\n\n@param reader \n       Reader for the stream to read from.\n@param isAborted\n       Optional function that returns true if the request has been aborted.\n       If the function returns true, the generator will stop reading the stream.\n       If the function is not provided, the generator will not stop reading the stream.\n */\nexport async function* readDataStream(\n  reader: ReadableStreamDefaultReader<Uint8Array>,\n  {\n    isAborted,\n  }: {\n    isAborted?: () => boolean;\n  } = {},\n): AsyncGenerator<StreamPartType> {\n  // implementation note: this slightly more complex algorithm is required\n  // to pass the tests in the edge environment.\n\n  const decoder = new TextDecoder();\n  const chunks: Uint8Array[] = [];\n  let totalLength = 0;\n\n  while (true) {\n    const { value } = await reader.read();\n\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        // if the last character is not a newline, we have not read the whole JSON value\n        continue;\n      }\n    }\n\n    if (chunks.length === 0) {\n      break; // we have reached the end of the stream\n    }\n\n    const concatenatedChunks = concatChunks(chunks, totalLength);\n    totalLength = 0;\n\n    const streamParts = decoder\n      .decode(concatenatedChunks, { stream: true })\n      .split('\\n')\n      .filter(line => line !== '') // splitting leaves an empty string at the end\n      .map(parseStreamPart);\n\n    for (const streamPart of streamParts) {\n      yield streamPart;\n    }\n\n    // The request has been aborted, stop reading the stream.\n    if (isAborted?.()) {\n      reader.cancel();\n      break;\n    }\n  }\n}\n","import { generateId as generateIdFunction } from './generate-id';\nimport { readDataStream } from './read-data-stream';\nimport type { FunctionCall, JSONValue, Message, ToolCall } from './types';\n\ntype PrefixMap = {\n  text?: Message;\n  function_call?: Message & {\n    role: 'assistant';\n    function_call: FunctionCall;\n  };\n  tool_calls?: Message & {\n    role: 'assistant';\n    tool_calls: ToolCall[];\n  };\n  data: JSONValue[];\n};\n\nfunction assignAnnotationsToMessage<T extends Message | null | undefined>(\n  message: T,\n  annotations: JSONValue[] | undefined,\n): T {\n  if (!message || !annotations || !annotations.length) return message;\n  return { ...message, annotations: [...annotations] } as T;\n}\n\nexport async function parseComplexResponse({\n  reader,\n  abortControllerRef,\n  update,\n  onFinish,\n  generateId = generateIdFunction,\n  getCurrentDate = () => new Date(),\n}: {\n  reader: ReadableStreamDefaultReader<Uint8Array>;\n  abortControllerRef?: {\n    current: AbortController | null;\n  };\n  update: (merged: Message[], data: JSONValue[] | undefined) => void;\n  onFinish?: (prefixMap: PrefixMap) => void;\n  generateId?: () => string;\n  getCurrentDate?: () => Date;\n}) {\n  const createdAt = getCurrentDate();\n  const prefixMap: PrefixMap = {\n    data: [],\n  };\n\n  // keep list of current message annotations for message\n  let message_annotations: JSONValue[] | undefined = undefined;\n\n  // we create a map of each prefix, and for each prefixed message we push to the map\n  for await (const { type, value } of readDataStream(reader, {\n    isAborted: () => abortControllerRef?.current === null,\n  })) {\n    if (type === 'text') {\n      if (prefixMap['text']) {\n        prefixMap['text'] = {\n          ...prefixMap['text'],\n          content: (prefixMap['text'].content || '') + value,\n        };\n      } else {\n        prefixMap['text'] = {\n          id: generateId(),\n          role: 'assistant',\n          content: value,\n          createdAt,\n        };\n      }\n    }\n\n    // Tool invocations are part of an assistant message\n    if (type === 'tool_call') {\n      // create message if it doesn't exist\n      if (prefixMap.text == null) {\n        prefixMap.text = {\n          id: generateId(),\n          role: 'assistant',\n          content: '',\n          createdAt,\n        };\n      }\n\n      if (prefixMap.text.toolInvocations == null) {\n        prefixMap.text.toolInvocations = [];\n      }\n\n      prefixMap.text.toolInvocations.push(value);\n    } else if (type === 'tool_result') {\n      // create message if it doesn't exist\n      if (prefixMap.text == null) {\n        prefixMap.text = {\n          id: generateId(),\n          role: 'assistant',\n          content: '',\n          createdAt,\n        };\n      }\n\n      if (prefixMap.text.toolInvocations == null) {\n        prefixMap.text.toolInvocations = [];\n      }\n\n      // find if there is any tool invocation with the same toolCallId\n      // and replace it with the result\n      const toolInvocationIndex = prefixMap.text.toolInvocations.findIndex(\n        invocation => invocation.toolCallId === value.toolCallId,\n      );\n\n      if (toolInvocationIndex !== -1) {\n        prefixMap.text.toolInvocations[toolInvocationIndex] = value;\n      } else {\n        prefixMap.text.toolInvocations.push(value);\n      }\n    }\n\n    let functionCallMessage: Message | null | undefined = null;\n\n    if (type === 'function_call') {\n      prefixMap['function_call'] = {\n        id: generateId(),\n        role: 'assistant',\n        content: '',\n        function_call: value.function_call,\n        name: value.function_call.name,\n        createdAt,\n      };\n\n      functionCallMessage = prefixMap['function_call'];\n    }\n\n    let toolCallMessage: Message | null | undefined = null;\n\n    if (type === 'tool_calls') {\n      prefixMap['tool_calls'] = {\n        id: generateId(),\n        role: 'assistant',\n        content: '',\n        tool_calls: value.tool_calls,\n        createdAt,\n      };\n\n      toolCallMessage = prefixMap['tool_calls'];\n    }\n\n    if (type === 'data') {\n      prefixMap['data'].push(...value);\n    }\n\n    let responseMessage = prefixMap['text'];\n\n    if (type === 'message_annotations') {\n      if (!message_annotations) {\n        message_annotations = [...value];\n      } else {\n        message_annotations.push(...value);\n      }\n\n      // Update any existing message with the latest annotations\n      functionCallMessage = assignAnnotationsToMessage(\n        prefixMap['function_call'],\n        message_annotations,\n      );\n      toolCallMessage = assignAnnotationsToMessage(\n        prefixMap['tool_calls'],\n        message_annotations,\n      );\n      responseMessage = assignAnnotationsToMessage(\n        prefixMap['text'],\n        message_annotations,\n      );\n    }\n\n    // keeps the prefixMap up to date with the latest annotations, even if annotations preceded the message\n    if (message_annotations?.length) {\n      const messagePrefixKeys: (keyof PrefixMap)[] = [\n        'text',\n        'function_call',\n        'tool_calls',\n      ];\n      messagePrefixKeys.forEach(key => {\n        if (prefixMap[key]) {\n          (prefixMap[key] as Message).annotations = [...message_annotations!];\n        }\n      });\n    }\n\n    // We add function & tool calls and response messages to the messages[], but data is its own thing\n    const merged = [functionCallMessage, toolCallMessage, responseMessage]\n      .filter(Boolean)\n      .map(message => ({\n        ...assignAnnotationsToMessage(message, message_annotations),\n      })) as Message[];\n\n    update(merged, [...prefixMap['data']]); // make a copy of the data array\n  }\n\n  onFinish?.(prefixMap);\n\n  return {\n    messages: [\n      prefixMap.text,\n      prefixMap.function_call,\n      prefixMap.tool_calls,\n    ].filter(Boolean) as Message[],\n    data: prefixMap.data,\n  };\n}\n","import {\n  StreamPartType,\n  StreamStringPrefixes,\n  parseStreamPart,\n} from './stream-parts';\n\nexport * from './generate-id';\n\n// TODO remove (breaking change)\nexport { generateId as nanoid } from './generate-id';\n\n// Export stream data utilities for custom stream implementations,\n// both on the client and server side.\nexport type { StreamPart } from './stream-parts';\nexport { formatStreamPart, parseStreamPart } from './stream-parts';\nexport { readDataStream } from './read-data-stream';\n\n// simple decoder signatures:\nfunction createChunkDecoder(): (chunk: Uint8Array | undefined) => string;\nfunction createChunkDecoder(\n  complex: false,\n): (chunk: Uint8Array | undefined) => string;\n// complex decoder signature:\nfunction createChunkDecoder(\n  complex: true,\n): (chunk: Uint8Array | undefined) => StreamPartType[];\n// combined signature for when the client calls this function with a boolean:\nfunction createChunkDecoder(\n  complex?: boolean,\n): (chunk: Uint8Array | undefined) => StreamPartType[] | string;\nfunction createChunkDecoder(complex?: boolean) {\n  const decoder = new TextDecoder();\n\n  if (!complex) {\n    return function (chunk: Uint8Array | undefined): string {\n      if (!chunk) return '';\n      return decoder.decode(chunk, { stream: true });\n    };\n  }\n\n  return function (chunk: Uint8Array | undefined) {\n    const decoded = decoder\n      .decode(chunk, { stream: true })\n      .split('\\n')\n      .filter(line => line !== ''); // splitting leaves an empty string at the end\n\n    return decoded.map(parseStreamPart).filter(Boolean);\n  };\n}\n\nexport { createChunkDecoder };\n\nexport const isStreamStringEqualToType = (\n  type: keyof typeof StreamStringPrefixes,\n  value: string,\n): value is StreamString =>\n  value.startsWith(`${StreamStringPrefixes[type]}:`) && value.endsWith('\\n');\n\nexport type StreamString =\n  `${(typeof StreamStringPrefixes)[keyof typeof StreamStringPrefixes]}:${string}\\n`;\n","import { parseComplexResponse } from './parse-complex-response';\nimport { IdGenerator, JSONValue, Message } from './types';\nimport { createChunkDecoder } from './utils';\n\nexport async function callChatApi({\n  api,\n  messages,\n  body,\n  streamMode = 'stream-data',\n  credentials,\n  headers,\n  abortController,\n  restoreMessagesOnFailure,\n  onResponse,\n  onUpdate,\n  onFinish,\n  generateId,\n}: {\n  api: string;\n  messages: Omit<Message, 'id'>[];\n  body: Record<string, any>;\n  streamMode?: 'stream-data' | 'text';\n  credentials?: RequestCredentials;\n  headers?: HeadersInit;\n  abortController?: () => AbortController | null;\n  restoreMessagesOnFailure: () => void;\n  onResponse?: (response: Response) => void | Promise<void>;\n  onUpdate: (merged: Message[], data: JSONValue[] | undefined) => void;\n  onFinish?: (message: Message) => void;\n  generateId: IdGenerator;\n}) {\n  const response = await fetch(api, {\n    method: 'POST',\n    body: JSON.stringify({\n      messages,\n      ...body,\n    }),\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n    signal: abortController?.()?.signal,\n    credentials,\n  }).catch(err => {\n    restoreMessagesOnFailure();\n    throw err;\n  });\n\n  if (onResponse) {\n    try {\n      await onResponse(response);\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  if (!response.ok) {\n    restoreMessagesOnFailure();\n    throw new Error(\n      (await response.text()) || 'Failed to fetch the chat response.',\n    );\n  }\n\n  if (!response.body) {\n    throw new Error('The response body is empty.');\n  }\n\n  const reader = response.body.getReader();\n\n  switch (streamMode) {\n    case 'text': {\n      const decoder = createChunkDecoder();\n\n      const resultMessage = {\n        id: generateId(),\n        createdAt: new Date(),\n        role: 'assistant' as const,\n        content: '',\n      };\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          break;\n        }\n\n        resultMessage.content += decoder(value);\n        resultMessage.id = generateId();\n\n        // note: creating a new message object is required for Solid.js streaming\n        onUpdate([{ ...resultMessage }], []);\n\n        // The request has been aborted, stop reading the stream.\n        if (abortController?.() === null) {\n          reader.cancel();\n          break;\n        }\n      }\n\n      onFinish?.(resultMessage);\n\n      return {\n        messages: [resultMessage],\n        data: [],\n      };\n    }\n\n    case 'stream-data': {\n      return await parseComplexResponse({\n        reader,\n        abortControllerRef:\n          abortController != null ? { current: abortController() } : undefined,\n        update: onUpdate,\n        onFinish(prefixMap) {\n          if (onFinish && prefixMap.text != null) {\n            onFinish(prefixMap.text);\n          }\n        },\n        generateId,\n      });\n    }\n\n    default: {\n      const exhaustiveCheck: never = streamMode;\n      throw new Error(`Unknown stream mode: ${exhaustiveCheck}`);\n    }\n  }\n}\n","import {\n  ChatRequest,\n  FunctionCall,\n  JSONValue,\n  Message,\n  ToolCall,\n} from './types';\n\nexport async function processChatStream({\n  getStreamedResponse,\n  experimental_onFunctionCall,\n  experimental_onToolCall,\n  updateChatRequest,\n  getCurrentMessages,\n}: {\n  getStreamedResponse: () => Promise<\n    Message | { messages: Message[]; data: JSONValue[] }\n  >;\n  experimental_onFunctionCall?: (\n    chatMessages: Message[],\n    functionCall: FunctionCall,\n  ) => Promise<void | ChatRequest>;\n  experimental_onToolCall?: (\n    chatMessages: Message[],\n    toolCalls: ToolCall[],\n  ) => Promise<void | ChatRequest>;\n  updateChatRequest: (chatRequest: ChatRequest) => void;\n  getCurrentMessages: () => Message[];\n}) {\n  while (true) {\n    // TODO-STREAMDATA: This should be {  const { messages: streamedResponseMessages, data } =\n    // await getStreamedResponse(} once Stream Data is not experimental\n    const messagesAndDataOrJustMessage = await getStreamedResponse();\n\n    // Using experimental stream data\n    if ('messages' in messagesAndDataOrJustMessage) {\n      let hasFollowingResponse = false;\n\n      for (const message of messagesAndDataOrJustMessage.messages) {\n        // See if the message has a complete function call or tool call\n        if (\n          (message.function_call === undefined ||\n            typeof message.function_call === 'string') &&\n          (message.tool_calls === undefined ||\n            typeof message.tool_calls === 'string')\n        ) {\n          continue;\n        }\n\n        hasFollowingResponse = true;\n        // Try to handle function call\n        if (experimental_onFunctionCall) {\n          const functionCall = message.function_call;\n          // Make sure functionCall is an object\n          // If not, we got tool calls instead of function calls\n          if (typeof functionCall !== 'object') {\n            console.warn(\n              'experimental_onFunctionCall should not be defined when using tools',\n            );\n            continue;\n          }\n\n          // User handles the function call in their own functionCallHandler.\n          // The \"arguments\" key of the function call object will still be a string which will have to be parsed in the function handler.\n          // If the \"arguments\" JSON is malformed due to model error the user will have to handle that themselves.\n\n          const functionCallResponse: ChatRequest | void =\n            await experimental_onFunctionCall(\n              getCurrentMessages(),\n              functionCall,\n            );\n\n          // If the user does not return anything as a result of the function call, the loop will break.\n          if (functionCallResponse === undefined) {\n            hasFollowingResponse = false;\n            break;\n          }\n\n          // A function call response was returned.\n          // The updated chat with function call response will be sent to the API in the next iteration of the loop.\n          updateChatRequest(functionCallResponse);\n        }\n        // Try to handle tool call\n        if (experimental_onToolCall) {\n          const toolCalls = message.tool_calls;\n          // Make sure toolCalls is an array of objects\n          // If not, we got function calls instead of tool calls\n          if (\n            !Array.isArray(toolCalls) ||\n            toolCalls.some(toolCall => typeof toolCall !== 'object')\n          ) {\n            console.warn(\n              'experimental_onToolCall should not be defined when using tools',\n            );\n            continue;\n          }\n\n          // User handles the function call in their own functionCallHandler.\n          // The \"arguments\" key of the function call object will still be a string which will have to be parsed in the function handler.\n          // If the \"arguments\" JSON is malformed due to model error the user will have to handle that themselves.\n          const toolCallResponse: ChatRequest | void =\n            await experimental_onToolCall(getCurrentMessages(), toolCalls);\n\n          // If the user does not return anything as a result of the function call, the loop will break.\n          if (toolCallResponse === undefined) {\n            hasFollowingResponse = false;\n            break;\n          }\n\n          // A function call response was returned.\n          // The updated chat with function call response will be sent to the API in the next iteration of the loop.\n          updateChatRequest(toolCallResponse);\n        }\n      }\n      if (!hasFollowingResponse) {\n        break;\n      }\n    } else {\n      const streamedResponseMessage = messagesAndDataOrJustMessage;\n\n      // TODO-STREAMDATA: Remove this once Stream Data is not experimental\n      if (\n        (streamedResponseMessage.function_call === undefined ||\n          typeof streamedResponseMessage.function_call === 'string') &&\n        (streamedResponseMessage.tool_calls === undefined ||\n          typeof streamedResponseMessage.tool_calls === 'string')\n      ) {\n        break;\n      }\n\n      // If we get here and are expecting a function call, the message should have one, if not warn and continue\n      if (experimental_onFunctionCall) {\n        const functionCall = streamedResponseMessage.function_call;\n        if (!(typeof functionCall === 'object')) {\n          console.warn(\n            'experimental_onFunctionCall should not be defined when using tools',\n          );\n          continue;\n        }\n        const functionCallResponse: ChatRequest | void =\n          await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n\n        // If the user does not return anything as a result of the function call, the loop will break.\n        if (functionCallResponse === undefined) break;\n        // A function call response was returned.\n        // The updated chat with function call response will be sent to the API in the next iteration of the loop.\n        fixFunctionCallArguments(functionCallResponse);\n        updateChatRequest(functionCallResponse);\n      }\n      // If we get here and are expecting a tool call, the message should have one, if not warn and continue\n      if (experimental_onToolCall) {\n        const toolCalls = streamedResponseMessage.tool_calls;\n        if (!(typeof toolCalls === 'object')) {\n          console.warn(\n            'experimental_onToolCall should not be defined when using functions',\n          );\n          continue;\n        }\n        const toolCallResponse: ChatRequest | void =\n          await experimental_onToolCall(getCurrentMessages(), toolCalls);\n\n        // If the user does not return anything as a result of the function call, the loop will break.\n        if (toolCallResponse === undefined) break;\n        // A function call response was returned.\n        // The updated chat with function call response will be sent to the API in the next iteration of the loop.\n        fixFunctionCallArguments(toolCallResponse);\n        updateChatRequest(toolCallResponse);\n      }\n\n      // Make sure function call arguments are sent back to the API as a string\n      function fixFunctionCallArguments(response: ChatRequest) {\n        for (const message of response.messages) {\n          if (message.tool_calls !== undefined) {\n            for (const toolCall of message.tool_calls) {\n              if (typeof toolCall === 'object') {\n                if (\n                  toolCall.function.arguments &&\n                  typeof toolCall.function.arguments !== 'string'\n                ) {\n                  toolCall.function.arguments = JSON.stringify(\n                    toolCall.function.arguments,\n                  );\n                }\n              }\n            }\n          }\n          if (message.function_call !== undefined) {\n            if (typeof message.function_call === 'object') {\n              if (\n                message.function_call.arguments &&\n                typeof message.function_call.arguments !== 'string'\n              ) {\n                message.function_call.arguments = JSON.stringify(\n                  message.function_call.arguments,\n                );\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n","import { useSWR } from 'sswr';\nimport { Readable, Writable, derived, get, writable } from 'svelte/store';\nimport { callCompletionApi } from '../shared/call-completion-api';\nimport type {\n  JSONValue,\n  RequestOptions,\n  UseCompletionOptions,\n} from '../shared/types';\n\nexport type { UseCompletionOptions };\n\nexport type UseCompletionHelpers = {\n  /** The current completion result */\n  completion: Readable<string>;\n  /** The error object of the API request */\n  error: Readable<undefined | Error>;\n  /**\n   * Send a new prompt to the API endpoint and update the completion state.\n   */\n  complete: (\n    prompt: string,\n    options?: RequestOptions,\n  ) => Promise<string | null | undefined>;\n  /**\n   * Abort the current API request but keep the generated tokens.\n   */\n  stop: () => void;\n  /**\n   * Update the `completion` state locally.\n   */\n  setCompletion: (completion: string) => void;\n  /** The current value of the input */\n  input: Writable<string>;\n  /**\n   * Form submission handler to automatically reset input and append a user message\n   * @example\n   * ```jsx\n   * <form onSubmit={handleSubmit}>\n   *  <input onChange={handleInputChange} value={input} />\n   * </form>\n   * ```\n   */\n  handleSubmit: (e: any) => void;\n  /** Whether the API request is in progress */\n  isLoading: Readable<boolean | undefined>;\n\n  /** Additional data added on the server via StreamData */\n  data: Readable<JSONValue[] | undefined>;\n};\n\nlet uniqueId = 0;\n\nconst store: Record<string, any> = {};\n\nexport function useCompletion({\n  api = '/api/completion',\n  id,\n  initialCompletion = '',\n  initialInput = '',\n  credentials,\n  headers,\n  body,\n  streamMode,\n  onResponse,\n  onFinish,\n  onError,\n}: UseCompletionOptions = {}): UseCompletionHelpers {\n  // Generate an unique id for the completion if not provided.\n  const completionId = id || `completion-${uniqueId++}`;\n\n  const key = `${api}|${completionId}`;\n  const {\n    data,\n    mutate: originalMutate,\n    isLoading: isSWRLoading,\n  } = useSWR<string>(key, {\n    fetcher: () => store[key] || initialCompletion,\n    fallbackData: initialCompletion,\n  });\n\n  const streamData = writable<JSONValue[] | undefined>(undefined);\n\n  const loading = writable<boolean>(false);\n\n  // Force the `data` to be `initialCompletion` if it's `undefined`.\n  data.set(initialCompletion);\n\n  const mutate = (data: string) => {\n    store[key] = data;\n    return originalMutate(data);\n  };\n\n  // Because of the `fallbackData` option, the `data` will never be `undefined`.\n  const completion = data as Writable<string>;\n\n  const error = writable<undefined | Error>(undefined);\n\n  let abortController: AbortController | null = null;\n\n  const complete: UseCompletionHelpers['complete'] = async (\n    prompt: string,\n    options?: RequestOptions,\n  ) => {\n    const existingData = get(streamData);\n    return callCompletionApi({\n      api,\n      prompt,\n      credentials,\n      headers: {\n        ...headers,\n        ...options?.headers,\n      },\n      body: {\n        ...body,\n        ...options?.body,\n      },\n      streamMode,\n      setCompletion: mutate,\n      setLoading: loadingState => loading.set(loadingState),\n      setError: err => error.set(err),\n      setAbortController: controller => {\n        abortController = controller;\n      },\n      onResponse,\n      onFinish,\n      onError,\n      onData(data) {\n        streamData.set([...(existingData || []), ...(data || [])]);\n      },\n    });\n  };\n\n  const stop = () => {\n    if (abortController) {\n      abortController.abort();\n      abortController = null;\n    }\n  };\n\n  const setCompletion = (completion: string) => {\n    mutate(completion);\n  };\n\n  const input = writable(initialInput);\n\n  const handleSubmit = (e: any) => {\n    e.preventDefault();\n    const inputValue = get(input);\n    if (!inputValue) return;\n    return complete(inputValue);\n  };\n\n  const isLoading = derived(\n    [isSWRLoading, loading],\n    ([$isSWRLoading, $loading]) => {\n      return $isSWRLoading || $loading;\n    },\n  );\n\n  return {\n    completion,\n    complete,\n    error,\n    stop,\n    setCompletion,\n    input,\n    handleSubmit,\n    isLoading,\n    data: streamData,\n  };\n}\n","import { readDataStream } from './read-data-stream';\nimport { JSONValue } from './types';\nimport { createChunkDecoder } from './utils';\n\nexport async function callCompletionApi({\n  api,\n  prompt,\n  credentials,\n  headers,\n  body,\n  streamMode = 'stream-data',\n  setCompletion,\n  setLoading,\n  setError,\n  setAbortController,\n  onResponse,\n  onFinish,\n  onError,\n  onData,\n}: {\n  api: string;\n  prompt: string;\n  credentials?: RequestCredentials;\n  headers?: HeadersInit;\n  body: Record<string, any>;\n  streamMode?: 'stream-data' | 'text';\n  setCompletion: (completion: string) => void;\n  setLoading: (loading: boolean) => void;\n  setError: (error: Error | undefined) => void;\n  setAbortController: (abortController: AbortController | null) => void;\n  onResponse?: (response: Response) => void | Promise<void>;\n  onFinish?: (prompt: string, completion: string) => void;\n  onError?: (error: Error) => void;\n  onData?: (data: JSONValue[]) => void;\n}) {\n  try {\n    setLoading(true);\n    setError(undefined);\n\n    const abortController = new AbortController();\n    setAbortController(abortController);\n\n    // Empty the completion immediately.\n    setCompletion('');\n\n    const res = await fetch(api, {\n      method: 'POST',\n      body: JSON.stringify({\n        prompt,\n        ...body,\n      }),\n      credentials,\n      headers: {\n        'Content-Type': 'application/json',\n        ...headers,\n      },\n      signal: abortController.signal,\n    }).catch(err => {\n      throw err;\n    });\n\n    if (onResponse) {\n      try {\n        await onResponse(res);\n      } catch (err) {\n        throw err;\n      }\n    }\n\n    if (!res.ok) {\n      throw new Error(\n        (await res.text()) || 'Failed to fetch the chat response.',\n      );\n    }\n\n    if (!res.body) {\n      throw new Error('The response body is empty.');\n    }\n\n    let result = '';\n    const reader = res.body.getReader();\n\n    switch (streamMode) {\n      case 'text': {\n        const decoder = createChunkDecoder();\n\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) {\n            break;\n          }\n\n          // Update the completion state with the new message tokens.\n          result += decoder(value);\n          setCompletion(result);\n\n          // The request has been aborted, stop reading the stream.\n          if (abortController === null) {\n            reader.cancel();\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case 'stream-data': {\n        for await (const { type, value } of readDataStream(reader, {\n          isAborted: () => abortController === null,\n        })) {\n          switch (type) {\n            case 'text': {\n              result += value;\n              setCompletion(result);\n              break;\n            }\n            case 'data': {\n              onData?.(value);\n              break;\n            }\n          }\n        }\n        break;\n      }\n\n      default: {\n        const exhaustiveCheck: never = streamMode;\n        throw new Error(`Unknown stream mode: ${exhaustiveCheck}`);\n      }\n    }\n\n    if (onFinish) {\n      onFinish(prompt, result);\n    }\n\n    setAbortController(null);\n    return result;\n  } catch (err) {\n    // Ignore abort errors as they are expected.\n    if ((err as any).name === 'AbortError') {\n      setAbortController(null);\n      return null;\n    }\n\n    if (err instanceof Error) {\n      if (onError) {\n        onError(err);\n      }\n    }\n\n    setError(err as Error);\n  } finally {\n    setLoading(false);\n  }\n}\n","import { isAbortError } from '@ai-sdk/provider-utils';\nimport { Readable, Writable, get, writable } from 'svelte/store';\nimport { generateId } from '../shared/generate-id';\nimport { readDataStream } from '../shared/read-data-stream';\nimport type {\n  AssistantStatus,\n  CreateMessage,\n  Message,\n  UseAssistantOptions,\n} from '../shared/types';\n\nlet uniqueId = 0;\n\nconst store: Record<string, any> = {};\n\nexport type UseAssistantHelpers = {\n  /**\n   * The current array of chat messages.\n   */\n  messages: Readable<Message[]>;\n\n  /**\n   * Update the message store with a new array of messages.\n   */\n  setMessages: (messages: Message[]) => void;\n\n  /**\n   * The current thread ID.\n   */\n  threadId: Readable<string | undefined>;\n\n  /**\n   * The current value of the input field.\n   */\n  input: Writable<string>;\n\n  /**\n   * Append a user message to the chat list. This triggers the API call to fetch\n   * the assistant's response.\n   * @param message The message to append\n   * @param requestOptions Additional options to pass to the API call\n   */\n  append: (\n    message: Message | CreateMessage,\n    requestOptions?: { data?: Record<string, string> },\n  ) => Promise<void>;\n\n  /**\nAbort the current request immediately, keep the generated tokens if any.\n   */\n  stop: () => void;\n\n  /**\n   * Form submission handler that automatically resets the input field and appends a user message.\n   */\n  submitMessage: (\n    e: any,\n    requestOptions?: { data?: Record<string, string> },\n  ) => Promise<void>;\n\n  /**\n   * The current status of the assistant. This can be used to show a loading indicator.\n   */\n  status: Readable<AssistantStatus>;\n\n  /**\n   * The error thrown during the assistant message processing, if any.\n   */\n  error: Readable<undefined | Error>;\n};\n\nexport function useAssistant({\n  api,\n  threadId: threadIdParam,\n  credentials,\n  headers,\n  body,\n  onError,\n}: UseAssistantOptions): UseAssistantHelpers {\n  // Generate a unique thread ID\n  const threadIdStore = writable<string | undefined>(threadIdParam);\n\n  // Initialize message, input, status, and error stores\n  const key = `${api}|${threadIdParam ?? `completion-${uniqueId++}`}`;\n  const messages = writable<Message[]>(store[key] || []);\n  const input = writable('');\n  const status = writable<AssistantStatus>('awaiting_message');\n  const error = writable<undefined | Error>(undefined);\n\n  // To manage aborting the current fetch request\n  let abortController: AbortController | null = null;\n\n  // Update the message store\n  const mutateMessages = (newMessages: Message[]) => {\n    store[key] = newMessages;\n    messages.set(newMessages);\n  };\n\n  // Function to handle API calls and state management\n  async function append(\n    message: Message | CreateMessage,\n    requestOptions?: { data?: Record<string, string> },\n  ) {\n    status.set('in_progress');\n    abortController = new AbortController(); // Initialize a new AbortController\n\n    // Add the new message to the existing array\n    mutateMessages([\n      ...get(messages),\n      { ...message, id: message.id ?? generateId() },\n    ]);\n\n    input.set('');\n\n    try {\n      const result = await fetch(api, {\n        method: 'POST',\n        credentials,\n        signal: abortController.signal,\n        headers: { 'Content-Type': 'application/json', ...headers },\n        body: JSON.stringify({\n          ...body,\n          // always use user-provided threadId when available:\n          threadId: threadIdParam ?? get(threadIdStore) ?? null,\n          message: message.content,\n\n          // optional request data:\n          data: requestOptions?.data,\n        }),\n      });\n\n      if (result.body == null) {\n        throw new Error('The response body is empty.');\n      }\n\n      // Read the streamed response data\n      for await (const { type, value } of readDataStream(\n        result.body.getReader(),\n      )) {\n        switch (type) {\n          case 'assistant_message': {\n            mutateMessages([\n              ...get(messages),\n              {\n                id: value.id,\n                role: value.role,\n                content: value.content[0].text.value,\n              },\n            ]);\n            break;\n          }\n\n          case 'text': {\n            // text delta - add to last message:\n            mutateMessages(\n              get(messages).map((msg, index, array) => {\n                if (index === array.length - 1) {\n                  return { ...msg, content: msg.content + value };\n                }\n                return msg;\n              }),\n            );\n            break;\n          }\n\n          case 'data_message': {\n            mutateMessages([\n              ...get(messages),\n              {\n                id: value.id ?? generateId(),\n                role: 'data',\n                content: '',\n                data: value.data,\n              },\n            ]);\n            break;\n          }\n\n          case 'assistant_control_data': {\n            threadIdStore.set(value.threadId);\n\n            mutateMessages(\n              get(messages).map((msg, index, array) => {\n                if (index === array.length - 1) {\n                  return { ...msg, id: value.messageId };\n                }\n                return msg;\n              }),\n            );\n\n            break;\n          }\n\n          case 'error': {\n            error.set(new Error(value));\n            break;\n          }\n        }\n      }\n    } catch (err) {\n      // Ignore abort errors as they are expected when the user cancels the request:\n      if (isAbortError(error) && abortController?.signal?.aborted) {\n        abortController = null;\n        return;\n      }\n\n      if (onError && err instanceof Error) {\n        onError(err);\n      }\n\n      error.set(err as Error);\n    } finally {\n      abortController = null;\n      status.set('awaiting_message');\n    }\n  }\n\n  function setMessages(messages: Message[]) {\n    mutateMessages(messages);\n  }\n\n  function stop() {\n    if (abortController) {\n      abortController.abort();\n      abortController = null;\n    }\n  }\n\n  // Function to handle form submission\n  async function submitMessage(\n    e: any,\n    requestOptions?: { data?: Record<string, string> },\n  ) {\n    e.preventDefault();\n    const inputValue = get(input);\n    if (!inputValue) return;\n\n    await append({ role: 'user', content: inputValue }, requestOptions);\n  }\n\n  return {\n    messages,\n    error,\n    threadId: threadIdStore,\n    input,\n    append,\n    submitMessage,\n    status,\n    setMessages,\n    stop,\n  };\n}\n"],"mappings":"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","names":["e","c","A","W","D","K","v","p","w","q","x","S","h","O","w","E","F","streamParts","generateId","generateId","getStreamedResponse","fixFunctionCallArguments","generateId","F","data","chatRequest","messages","import_store","uniqueId","store","F","data","completion","import_store","uniqueId","store","messages"]}